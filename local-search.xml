<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>杂草识别</title>
    <link href="/2023/06/25/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB/"/>
    <url>/2023/06/25/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>本次任务是在第五周手写识别的基础上完成上一周10类杂草的识别，实现方式都一样，通过神经网络（CNN模型）来完成识别<br>首先是制作10类杂草的数据集<br>第一步在获取了500张以上的杂草后，由于每张杂草图片大小都不一样，还有一些图片上不是我们训练中所需要的部分，所以为了获取我们所感兴趣的部分我们需要python中的pillow来裁剪这些图片，制作数据集。<br>第一步:在图上估计获取感兴趣区域的大小  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#裁剪窗口</span><br>BOX_LEFT, BOX_UP, BOX_RIGHT, BOX_DOWN = <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">400</span><br>box = (BOX_LEFT, BOX_UP, BOX_RIGHT + BOX_LEFT, BOX_DOWN + BOX_UP)<br><span class="hljs-comment">#裁剪函数</span><br>roi_area = img.crop(box)<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB1.png" alt="img"><br>下一步就是制作数据集<br>分为测试集，训练集，验证集，训练集和验证集都放着10类杂草的图片，测试集放着训练完后预测的图片<br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB2.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB3.png" alt="img"><br>完成数据集的准备后，接下来是输入数据集，使用train_generator &#x3D; train_datagen.flow_from_directory(train_directory,target_size&#x3D;image_size,batch_size&#x3D;batch_size,class_mode&#x3D;’categorical’)生成数据。<br>接下来与第五周一样，创建CNN训练模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">model_load</span>(<span class="hljs-params">IMG_SHAPE=(<span class="hljs-params"><span class="hljs-number">224</span>, <span class="hljs-number">224</span>, <span class="hljs-number">3</span></span>), class_num=<span class="hljs-number">12</span></span>):<br>    <span class="hljs-comment"># 搭建模型</span><br>    model = tf.keras.models.Sequential([<br>        <span class="hljs-comment"># 对模型做归一化的处理，将0-255之间的数字统一处理到0到1之间</span><br>        tf.keras.layers.experimental.preprocessing.Rescaling(<span class="hljs-number">1.</span> / <span class="hljs-number">255</span>, input_shape=IMG_SHAPE),<br>        <span class="hljs-comment"># 卷积层，该卷积层的输出为32个通道，卷积核的大小是3*3，激活函数为relu</span><br>        tf.keras.layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>        <span class="hljs-comment"># 添加池化层，池化的kernel大小是2*2</span><br>        tf.keras.layers.MaxPooling2D(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>),<br>        <span class="hljs-comment"># Add another convolution</span><br>        <span class="hljs-comment"># 卷积层，输出为64个通道，卷积核大小为3*3，激活函数为relu</span><br>        tf.keras.layers.Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>        <span class="hljs-comment"># 池化层，最大池化，对2*2的区域进行池化操作</span><br>        tf.keras.layers.MaxPooling2D(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>),<br>        <span class="hljs-comment"># 将二维的输出转化为一维</span><br>        tf.keras.layers.Flatten(),<br>        <span class="hljs-comment"># The same 128 dense layers, and 10 output layers as in the pre-convolution example:</span><br>        tf.keras.layers.Dense(<span class="hljs-number">128</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>        <span class="hljs-comment"># 通过softmax函数将模型输出为类名长度的神经元上，激活函数采用softmax对应概率值</span><br>        tf.keras.layers.Dense(class_num, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)<br>    ])<br>    <span class="hljs-comment"># 输出模型信息</span><br>    model.summary()<br>    <span class="hljs-comment"># 指明模型的训练参数，优化器为sgd优化器，损失函数为交叉熵损失函数</span><br>    model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;sgd&#x27;</span>, loss=<span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br>    <span class="hljs-comment"># 返回模型</span><br>    <span class="hljs-keyword">return</span> model<br>```  <br>用model.fit()方法开始训练  <br>训练结果如下所示:  <br>![img](/img/杂草识别<span class="hljs-number">4.</span>png)  <br>准确度到达<span class="hljs-number">0.93</span>  <br>![img](/img/杂草识别<span class="hljs-number">5.</span>png)  <br>![img](/img/杂草识别<span class="hljs-number">6.</span>png)  <br>接下来是对利用训练好的模型对测试集中的<span class="hljs-number">10</span>类杂草图片进行预测<br>代码如下  <br>```python<br>predictions = model.predict(test_image)<br>class_names = [<span class="hljs-string">&#x27;Clinopodium polycephalum&#x27;</span>, <span class="hljs-string">&#x27;Duchesnea indica&#x27;</span>, <span class="hljs-string">&#x27;Eleusine indica&#x27;</span>, <span class="hljs-string">&#x27;Equisetum ramosissimum&#x27;</span>, <span class="hljs-string">&#x27;Lamium amplexicaule&#x27;</span>, <span class="hljs-string">&#x27;Phragmites australis&#x27;</span>, <span class="hljs-string">&#x27;Setaria viridis&#x27;</span>, <span class="hljs-string">&#x27;Taraxacum mongolicum&#x27;</span>, <span class="hljs-string">&#x27;Typha orientalis&#x27;</span>, <span class="hljs-string">&#x27;Xanthium strumarium&#x27;</span>] <span class="hljs-comment"># 类别名称</span><br>predicted_class = class_names[<span class="hljs-built_in">int</span>(predictions[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;这个杂草是: <span class="hljs-subst">&#123;predicted_class&#125;</span>&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>结果如下:<br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB7.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB8.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB9.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB10.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB11.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB12.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB13.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB14.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB15.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB16.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB17.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB18.png" alt="img"><br><img src="/img/%E6%9D%82%E8%8D%89%E8%AF%86%E5%88%AB19.png" alt="img">  </p><p>以上就是全部内容 </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>爬虫爬取图片</title>
    <link href="/2023/06/25/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87/"/>
    <url>/2023/06/25/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>本次任务是从网上爬取杂草图片<br>第一了解原理<br>本次实现是从百度图片上爬取<br>首先打开网页地址，F12打开开发者工具<br><img src="/img/%E7%88%AC%E8%99%AB1.png" alt="img"><br>由于每一张图片网站都对应着每一张图片，<br><img src="/img/%E7%88%AC%E8%99%AB2.png" alt="img"><br>现在的目的是获取这些图片网址。<br>本次任务是通过获取网页JSON文件来获取这些图片网址<br><img src="/img/%E7%88%AC%E8%99%AB3.png" alt="img"><br><img src="/img/%E7%88%AC%E8%99%AB4.png" alt="img"><br>其中thumbURL下的文本就是图片的地址<br>第二内容：<br>第一步是获取网址，通过访问网址来得到JSON信息<br><img src="/img/%E7%88%AC%E8%99%AB5.png" alt="img"><br>输出为:<br><img src="/img/%E7%88%AC%E8%99%AB6.png" alt="img"><br>由于是爬取500以上的图片得到这些网址后，访问网址用requests.get(url).json()方法来得到这些数据:<br>代码：<br><img src="/img/%E7%88%AC%E8%99%AB7.png" alt="img"><br>结果：<br><img src="/img/%E7%88%AC%E8%99%AB8.png" alt="img"><br>获取了这些图片网址,接下来就是保存这些图片<br>代码：<br><img src="/img/%E7%88%AC%E8%99%AB9.png" alt="img"><br>在已创建的文件目录下，用f.write()方法保存图片内容<br>以上就是整个过程<br>下面试爬取的杂草图片展示<br><img src="/img/%E7%88%AC%E8%99%AB10.png" alt="img"><br><img src="/img/%E7%88%AC%E8%99%AB11.png" alt="img"><br><img src="/img/%E7%88%AC%E8%99%AB12.png" alt="img"><br>其他种类杂草一样方法。以上就是这次任务全部内容。  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>minist手写识别</title>
    <link href="/2023/06/25/minist%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB/"/>
    <url>/2023/06/25/minist%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>本次任务是用卷神经网络完成手写识别<br>内容:<br>首先是构建CNN模型<br>CNN模型有输入层，卷积层，激励层，池化层，全连接层，输出层<br>第一层卷积将输入的28，28，1的图片通过卷积核3<em>3，共32个的卷积核形成32张量<br>再通过池化层将原来由28</em>28通过卷积核的张量缩小一倍变成14<em>14</em>32<br>第二层卷积层的卷积核<br>将上一层的池化结果继续卷积，卷积核为3<em>3,64个，变为14</em>14<em>62<br>同样经过池化层变为14</em>14<em>64<br>再经过全连接层变为4</em>4<em>64最后输出层输出1024</em>1*1的张量<br>代码部分为:<br><img src="/img/%E6%89%8B%E5%86%991.png" alt="img"><br>可以通过model.summary来看到模型的结构<br><img src="/img/%E6%89%8B%E5%86%992.png" alt="img"><br>接下来是数据集的输入<br>通过的是dataset库函数来输入共有60000张训练集和10000张测试集<br>代码如下<br><img src="/img/%E6%89%8B%E5%86%993.png" alt="img"><br>再构建完模型和输入数据集后开始训练<br>训练后的模型参数将保存在.&#x2F;ckpt&#x2F;cp-0005.ckpt里<br><img src="/img/%E6%89%8B%E5%86%994.png" alt="img"><br>训练结果:<br><img src="/img/%E6%89%8B%E5%86%995.png" alt="img"><br>准确到达0.98<br>在训练完模型后对测试文件下的图片进行预测<br><img src="/img/%E6%89%8B%E5%86%996.png" alt="img"><br>代码部分首先是要加载训练好的模型，将模型权重输入<br><img src="/img/%E5%9B%BE%E7%89%8712.png" alt="img"><br>之后就是通过model.predict函数来预测<br><img src="/img/%E6%89%8B%E5%86%997.png" alt="img"><br>输入图片文件地址<br><img src="/img/%E6%89%8B%E5%86%998.png" alt="img"><br>预测结果为<br><img src="/img/%E6%89%8B%E5%86%999.png" alt="img"><br><img src="/img/%E6%89%8B%E5%86%9910.png" alt="img"><br>由结果可以看出在预测时，他会返回每个数字的可能性<br>[2.2452707e-07 3.6458367e-08 2.6482989e-09 8.6910489e-08 6.6781249e-06<br> 2.4170979e-06 6.4976060e-09 1.0569422e-06 1.5694044e-06 9.9998796e-01]<br>再通过np.argmax()就可以的出来最优可能的数字<br><img src="/img/%E6%89%8B%E5%86%9911.png" alt="img"><br>上面是用matplotlib来绘制的预测数字，红色代码预测结果<br>以上就是全部内容 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> urllib<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetImage</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,keyword=<span class="hljs-string">&#x27;鲜花&#x27;</span>,paginator=<span class="hljs-number">1</span></span>):<br>        self.url = <span class="hljs-string">&#x27;http://image.baidu.com/search/acjson?&#x27;</span><br><br>        self.headers = &#123;<br>            <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.42&#x27;</span><br>        &#125;<br><br>        self.keyword = keyword<br>        self.paginator = paginator<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_param</span>(<span class="hljs-params">self</span>):<br><br>        keyword = urllib.parse.quote(self.keyword)<br>        params = []<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,self.paginator+<span class="hljs-number">1</span>):<br><br>            params.append(<br>               <span class="hljs-string">&#x27;tn=resultjson_com&amp;logid=10338332981203604364&amp;ipn=rj&amp;ct=201326592&amp;is=&amp;fp=result&amp;fr=&amp;word=&#123;&#125;&amp;queryWord=&#123;&#125;&amp;cl=2&amp;lm=-1&amp;ie=utf-8&amp;oe=utf-8&amp;adpicid=&amp;st=&amp;z=&amp;ic=&amp;hd=&amp;latest=&amp;copyright=&amp;s=&amp;se=&amp;tab=&amp;width=&amp;height=&amp;face=&amp;istype=&amp;qc=&amp;nc=1&amp;expermode=&amp;nojc=&amp;isAsync=&amp;pn=&#123;&#125;&amp;rn=30&amp;gsm=78&amp;1650241802208=&#x27;</span>.<span class="hljs-built_in">format</span>(keyword,keyword,<span class="hljs-number">30</span>*i)<br><br>            )<br>        <span class="hljs-keyword">return</span> params<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_urls</span>(<span class="hljs-params">self,params</span>):<br>        urls = []<br>        <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>            urls.append(self.url+param)<br>        <span class="hljs-keyword">return</span> urls<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_image_url</span>(<span class="hljs-params">self,urls</span>):<br>        image_url = []<br>        <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br>            json_data = requests.get(url,headers = self.headers).json()<br>            json_data = json_data.get(<span class="hljs-string">&#x27;data&#x27;</span>)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> json_data:<br>                <span class="hljs-keyword">if</span> i:<br>                    image_url.append(i.get(<span class="hljs-string">&#x27;thumbURL&#x27;</span>))<br>        <span class="hljs-keyword">return</span> image_url<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_image</span>(<span class="hljs-params">self,image_url</span>):<br>        <span class="hljs-comment">##根据图片url，存入图片</span><br>        file_name = os.path.join(<span class="hljs-string">&quot;&quot;</span>, self.keyword)<br>        <span class="hljs-comment">#print(file_name)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(file_name):<br>            os.makedirs(file_name)<br><br>        <span class="hljs-keyword">for</span> index,url <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(image_url,start=<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name+<span class="hljs-string">&#x27;/&#123;&#125;.jpg&#x27;</span>.<span class="hljs-built_in">format</span>(index),<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write(requests.get(url,headers=self.headers).content)<br><br>            <span class="hljs-keyword">if</span> index != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> index%<span class="hljs-number">30</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第&#123;&#125;页下载完成&quot;</span>.<span class="hljs-built_in">format</span>(index/<span class="hljs-number">30</span>))<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        params = self.get_param()<br>        urls = self.get_urls(params)<br>        image_url = self.get_image_url(urls)<br>        self.get_image(image_url=image_url)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    spider = GetImage(<span class="hljs-string">&#x27;蛇莓&#x27;</span>,<span class="hljs-number">20</span>)<br>    spider()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>尺寸检测</title>
    <link href="/2023/06/24/%E5%B0%BA%E5%AF%B8%E6%A3%80%E6%B5%8B/"/>
    <url>/2023/06/24/%E5%B0%BA%E5%AF%B8%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>本次实验是测量图像中的物体尺寸大小，完成本次实验的关键点是比率指标（pixels_per_metric）。比率指标是给定度量的像素数。为了获取pixels_per_metric，我们得需要找到一个参考物。得到参考物现实中的尺寸大小。从而pixels_per_metric&#x3D;pix(图像中的像素值)&#x2F;width(现实长度)，意为每width的长度有pix个像素，从而在得到其他被测物的像素值后除以pixels_per_metric&#x3D;pix便能测出其尺寸。</p><p>实现过程:</p><blockquote><ol><li>首先是将参考物的图片（用的是0.995英寸的美元）放在被测物的图片上合成一张新图<br><img src="/img/%E7%BE%8E%E5%85%83.png" alt="美元"><img src="/img/%E8%A2%AB%E6%B5%8B%E7%89%A9.png" alt="被测物"><br>合成结果:<br><img src="/img/%E8%A2%AB%E6%B5%8B%E7%89%A9.png" alt="合成图"><br>代码实现:</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">coin_img=cv2.imread(<span class="hljs-string">&quot;meiyuan1.jpg&quot;</span>,flags=<span class="hljs-number">1</span>)<br>img=cv2.imread(<span class="hljs-string">&quot;mea.jpg&quot;</span>,flags=<span class="hljs-number">1</span>)<br>coin_img=cv2.resize(coin_img,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-literal">None</span>,<span class="hljs-number">0.18</span>,<span class="hljs-number">0.18</span>)<br>img=cv2.resize(img,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-literal">None</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">0.2</span>)<br>h,w=img.shape[:<span class="hljs-number">2</span>]<br>h1,w1=coin_img.shape[:<span class="hljs-number">2</span>]<br><span class="hljs-comment">#合成图片</span><br>imageROI = np.ones((<span class="hljs-number">92</span>, <span class="hljs-number">94</span>, <span class="hljs-number">3</span>))<br>imageROI = coin_img[<span class="hljs-number">0</span>:<span class="hljs-number">92</span>, <span class="hljs-number">0</span>: <span class="hljs-number">94</span>]<br>img[<span class="hljs-number">10</span>:<span class="hljs-number">102</span>, <span class="hljs-number">10</span>:<span class="hljs-number">104</span>]=imageROI<br>cv2.imshow(<span class="hljs-string">&quot;img&quot;</span>,img)<br><br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>接下来是对图像预处理：通过高斯滤波，canny边缘检测，腐蚀和膨胀来获得图像的边缘信息，方便下一步获取轮廓<br>**高斯模糊  <img src="/img/%E9%AB%98%E6%96%AF.png" alt="高斯"><br>**边缘检测<img src="/img/%E8%BE%B9%E7%BC%98.png" alt="边缘"><br>**腐蚀和膨胀<img src="/img/%E8%86%A8%E8%83%80%E5%92%8C%E8%85%90%E8%9A%80.png" alt="膨胀和腐蚀"><br>代码:</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">photopretreatment</span>(<span class="hljs-params">image,SHOWerode=<span class="hljs-literal">False</span></span>):<br>    image=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)<br><br>    gaussian=cv2.GaussianBlur(image,(<span class="hljs-number">7</span>,<span class="hljs-number">7</span>),<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">#cv2.imshow(&quot;g&quot;,gaussian)</span><br>    canny=cv2.Canny(gaussian,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>)<br>    <span class="hljs-comment">#cv2.imshow(&quot;g&quot;,canny)</span><br>    dilate=cv2.dilate(canny,<span class="hljs-literal">None</span>,iterations=<span class="hljs-number">1</span>)<br>    erode = cv2.erode(dilate,<span class="hljs-literal">None</span>, iterations=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> SHOWerode:cv2.imshow(<span class="hljs-string">&quot;erode&quot;</span>,erode)<br>    <span class="hljs-keyword">return</span> erode<br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>下一步是通过cv2.findcontours()函数得到轮廓点和轮廓个数与层次关系则需要imutils.grab_contours()函数来抓取其中的轮廓，接下来就需要对轮廓进行排序从上到下从左到右（使用contours.sort_contours()函数），因为我们需要先对参考物进行测量得到pixels_per_metric后再对被测物测量。</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#找轮廓并排序</span><br>cnts=cv2.findContours(img1.copy(),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)<br>cnts=imutils.grab_contours(cnts)<span class="hljs-comment">#抓住轮廓</span><br>(cnts,_)=contours.sort_contours(cnts)<span class="hljs-comment">#轮廓排序</span><br><br><span class="hljs-comment">#定义pixpermectic</span><br>pixelsPerMetric = <span class="hljs-literal">None</span><br>width = <span class="hljs-number">0.955</span><br>```  <br><br>&gt; <span class="hljs-number">4.</span> 下一步是遍历轮廓，对物品画出其最小外界矩形。其中对于因噪声产生的轮廓通过cv2.contoursArea（）滤除，接着由于在之前cv2.findcontours()函数中第三个参数metho选的是cv2.CHAIN_APPROX_SIMPLE因此得到的轮廓是压缩水平和垂直的端点值，通过画出外接最小矩形后得到矩形的<span class="hljs-number">4</span>个顶点值，通过顶点画出轮廓<br>![轮廓<span class="hljs-number">1</span>](/img/轮廓<span class="hljs-number">1.</span>png)   <br>![轮廓<span class="hljs-number">2</span>](/img/轮廓<span class="hljs-number">2.</span>png)  <br>&gt;  ** 代码实现<br>```python<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> cnts:<br>    <span class="hljs-keyword">if</span> cv2.contourArea(c)&lt;<span class="hljs-number">100</span>:<br>        <span class="hljs-keyword">continue</span><br>    orig=img<br>    box=cv2.minAreaRect(c)<br>    box=cv2.boxPoints(box)<br>    box=np.array(box,dtype=<span class="hljs-string">&quot;int&quot;</span>)<br>    box=perspective.order_points(box)<br>    cv2.drawContours(orig,[box.astype(<span class="hljs-string">&quot;int&quot;</span>)],-<span class="hljs-number">1</span>,(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment">#给4个点画圈</span><br>    <span class="hljs-keyword">for</span> (x,y) <span class="hljs-keyword">in</span> box:<br>        cv2.circle(orig,(<span class="hljs-built_in">int</span>(x),<span class="hljs-built_in">int</span>(y)),<span class="hljs-number">5</span>,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>),<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>接着由得到4个顶点值画出矩形再通过4个点画出各个中点后计算出距离从而得到像素值后除以pixels_per_metric得到测量值。<br><img src="/img/%E8%BD%AE%E5%BB%933.png" alt="轮廓3"><br><img src="/img/%E8%BD%AE%E5%BB%934.png" alt="轮廓4"><br>** 代码实现：</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#由四个角得到长度和宽度计算尺寸</span><br>(tl,tr,br,bl)=box<br>(tcx,tcy)= midpoint(tl,tr)<br>(bcx,bcy) = midpoint(bl,br)<br>(lcx,lcy)= midpoint(tl,bl)<br>(rcx,rcy)= midpoint(tr,br)<br><br>cv2.circle(orig, (<span class="hljs-built_in">int</span>(tcx),<span class="hljs-built_in">int</span>(tcy)), <span class="hljs-number">5</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br>cv2.circle(orig, (<span class="hljs-built_in">int</span>(bcx),<span class="hljs-built_in">int</span>(bcy)), <span class="hljs-number">5</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br>cv2.circle(orig, (<span class="hljs-built_in">int</span>(lcx),<span class="hljs-built_in">int</span>(lcy)), <span class="hljs-number">5</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br>cv2.circle(orig, (<span class="hljs-built_in">int</span>(rcx),<span class="hljs-built_in">int</span>(rcy)), <span class="hljs-number">5</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br><br>cv2.line(orig,(<span class="hljs-built_in">int</span>(tcx),<span class="hljs-built_in">int</span>(tcy)),(<span class="hljs-built_in">int</span>(bcx),<span class="hljs-built_in">int</span>(bcy)),(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>),<span class="hljs-number">3</span>)<br>cv2.line(orig, (<span class="hljs-built_in">int</span>(lcx),<span class="hljs-built_in">int</span>(lcy)), (<span class="hljs-built_in">int</span>(rcx),<span class="hljs-built_in">int</span>(rcy)), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><blockquote><p>另一张是以橡皮为参考物的测量<br><img src="/img/%E8%BD%AE%E5%BB%935.png" alt="轮廓5"><br><img src="/img/%E8%BD%AE%E5%BB%936.png" alt="轮廓6">  </p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>车道线检测</title>
    <link href="/2023/06/23/opencv%E8%BD%A6%E9%81%93%E7%BA%BF%E6%A3%80%E6%B5%8B/"/>
    <url>/2023/06/23/opencv%E8%BD%A6%E9%81%93%E7%BA%BF%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>本次学习内容是通过opencv的库函数来实现对一段视频车道线的检测。</p><h1 id="相机标定矫正畸变图像"><a href="#相机标定矫正畸变图像" class="headerlink" title="相机标定矫正畸变图像"></a>相机标定矫正畸变图像</h1><h2 id="相机标定"><a href="#相机标定" class="headerlink" title="相机标定"></a>相机标定</h2><p>将世界坐标系的坐标信息转到像素坐标系上，来确定空间3维几何位置与图像中对应点之间的关系。涉及变换的坐标系有世界坐标系，相机坐标系，图像坐标系，像素坐标系。</p><h3 id="世界坐标系到相机坐标系"><a href="#世界坐标系到相机坐标系" class="headerlink" title="世界坐标系到相机坐标系"></a>世界坐标系到相机坐标系</h3><p><img src="/img/%E5%9D%90%E6%A0%87%E7%B3%BB1.png" alt="世界坐标系到相机坐标系"><br>两个坐标系之间的变化为旋转和平移可以用旋转平移矩阵来表示：</p><p>$\begin{pmatrix}Xc \\ Yc \\ Zc \end{pmatrix}&#x3D;\begin{pmatrix}R &amp;t \\ 0 &amp; 1 \end{pmatrix}\cdot \begin{pmatrix}Xw \\ Yw \\ Zw \end{pmatrix}$<br>其中R为旋转矩阵，t为平移矩阵。</p><h3 id="相机坐标系到图像坐标系的变换"><a href="#相机坐标系到图像坐标系的变换" class="headerlink" title="相机坐标系到图像坐标系的变换"></a>相机坐标系到图像坐标系的变换</h3><p><img src="/img/%E5%9D%90%E6%A0%87%E7%B3%BB2.png" alt="世界坐标系到相机坐标系"><br>由相似三角形可以得出关系:$\frac{f}{Zc}&#x3D;\frac{x}{Xc}&#x3D;\frac{y}{Yc}$<br>从而写出矩阵形式为：</p><p>$$Zc\begin{pmatrix}x \\ y \\ 1 \end{pmatrix}&#x3D;\begin{pmatrix}f &amp; 0 &amp;0 &amp;0 \\ 0 &amp; f &amp; 0 &amp;0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{pmatrix}\cdot \begin{pmatrix}Xc \\ Yc \\ Zc \\ 1 \end{pmatrix}$$<br>f为焦距。</p><h3 id="图像坐标系到像素坐标系"><a href="#图像坐标系到像素坐标系" class="headerlink" title="图像坐标系到像素坐标系"></a>图像坐标系到像素坐标系</h3><p><img src="/img/%E5%9D%90%E6%A0%87%E7%B3%BB3.png" alt="世界坐标系到相机坐标系"><br>$\begin{pmatrix}u \\ v \\ 1 \end{pmatrix}&#x3D;\begin{pmatrix}\frac{x}{dx} &amp;0 &amp;u0 \\ 0 &amp;\frac{y}{dy} &amp;v0 \ 0 &amp; 0 &amp; 1 \end{pmatrix}\cdot \begin{pmatrix}x \\ y \\ 1 \end{pmatrix}$</p><p>综上所述变化为：$Zc\begin{pmatrix}u \\ v \\ 1 \end{pmatrix}&#x3D;\begin{pmatrix}\frac{x}{dx} &amp;0 &amp;u0 \ 0 &amp;\frac{y}{dy} &amp;v0 \ 0 &amp; 0 &amp; 1 \end{pmatrix}\cdot\begin{pmatrix}f &amp; 0 &amp;0 &amp;0 \\ 0 &amp; f &amp; 0 &amp;0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{pmatrix}\cdot \begin{pmatrix}R &amp;t \\ 0 &amp; 1 \end{pmatrix}\cdot \begin{pmatrix}Xw \\ Yw \\ Zw \end{pmatrix}$</p><h3 id="畸变"><a href="#畸变" class="headerlink" title="畸变"></a>畸变</h3><p>由于透镜的影响使得图片会产生畸变（主要分为两大类切向与径向畸变）<br>切向：$x_{cor}&#x3D;x+2p_{1}xy+p_{2}(r^{2}+2x^{2}) y_{cor}&#x3D;y+2p_{2}xy+p_{1}(r^{2}+2y^{2})$<br>径向:$x_{cor}&#x3D;x(1+k_{1}r^{2}+k_{2}r^{4}+k_{3}r^{6}) y_{cor}&#x3D;y(1+k_{1}r^{2}+k_{2}r^{4}+k_{3}r^{6})$<br>接着就是将纠正后的点通过内参到像素平面上</p><p>$\left{\begin{matrix}u&#x3D;f_{x}x_{cor}+u_{0} \\ v&#x3D;f_{y}y_{cor}+v_{0} \end{matrix}\right.$<br>其中fx为x&#x2F;dx，fy同理<br>本文通过opencv函数实现相机标定与畸变校正<br>通过不同角度拍摄的棋盘格来完成相机的标定，本文的棋盘格数据集为如下图所示<br><img src="/img/%E6%A3%8B%E7%9B%98%E6%A0%BC.jpeg" alt="棋盘格"></p><h3 id="代码实现矫正"><a href="#代码实现矫正" class="headerlink" title="代码实现矫正"></a>代码实现矫正</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">paths=glob.glob(<span class="hljs-string">r&#x27;../IR_camera_calib_img/ca*.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure><p>由glob.glob（）函数获得20张棋盘位置，函数返回值用列表形式储存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ret,corners=cv2.findChessboardCorners(gray,(<span class="hljs-number">9</span>,<span class="hljs-number">6</span>),<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>接下里用cv2.findChessboardCorners来找到棋盘格的内交点的像素坐标，由上图棋盘格能看出内角点为w&#x3D;9，h&#x3D;6 。</p><p>由于世界坐标能够自行进行设置，本文将世界坐标系的Z轴设为0。由此获得世界坐标系形式为（1,0,0），（2,0,0），（3,0,0）····为内交点的世界坐标用wld_object来保存，而通过cv2.findChessboardCorners获得的交点像素坐标系由img_object&#x3D;[]保存，下一步带入cv2.calibrateCamera（）来获得mtx是相机的内参矩阵；dist表述的相机畸变参数；rvecs表示旋转参数：；tvecs表示translation vectors，是平移参数。</p><p>最后通过cv2.undistort(img1,mtx,dis,None,mtx)来完成畸变校正</p><p>实现代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python">worldobject=np.zeros((<span class="hljs-number">9</span>*<span class="hljs-number">6</span>,<span class="hljs-number">3</span>),np.float32)<br>worldobject[:,:<span class="hljs-number">2</span>]=np.mgrid[<span class="hljs-number">0</span>:<span class="hljs-number">9</span>,<span class="hljs-number">0</span>:<span class="hljs-number">6</span>].T.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">#</span><br>wld_object=[]<br>img_object=[]<br>paths=glob.glob(<span class="hljs-string">r&#x27;../IR_camera_calib_img/ca*.jpg&#x27;</span>)<br><br><span class="hljs-comment">#plt.figure(figsize=(10, 6))</span><br><span class="hljs-comment">#print(paths)</span><br><span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> paths:<br>    img= cv2.imread(path,flags=<span class="hljs-number">1</span>)<br>    gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<br><br>    <span class="hljs-comment">#找内角点</span><br>    ret,corners=cv2.findChessboardCorners(gray,(<span class="hljs-number">9</span>,<span class="hljs-number">6</span>),<span class="hljs-literal">None</span>)<br><br><br>    <span class="hljs-keyword">if</span> ret == <span class="hljs-literal">True</span>:<br>        wld_object.append(worldobject)<br>        img_object.append(corners)<br>        i+=<span class="hljs-number">1</span><br>        <span class="hljs-comment">#cv2.drawChessboardCorners(img,(11,8),corners,ret)</span><br>        <span class="hljs-comment">#cv2.imshow(&#x27;img&#x27;,img)</span><br>        <span class="hljs-comment">#plt.subplot(3,6,i)</span><br>        <span class="hljs-comment">#plt.imshow(img)</span><br>        <span class="hljs-comment">#cv2.waitKey(0)</span><br>        <span class="hljs-comment">#cv2.destroyAllWindows()</span><br><span class="hljs-comment">#plt.show()</span><br><br><span class="hljs-comment">#img1=cv2.imread(&#x27;100000.png&#x27;)</span><br>ret,mtx,dis,rvecs,tvecs=cv2.calibrateCamera(wld_object,img_object,gray.shape[::-<span class="hljs-number">1</span>],<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>)<br><br><br><span class="hljs-comment">#校正</span><br>img1=cv2.imread(<span class="hljs-string">&#x27;straight_lines1.jpg&#x27;</span>,)<br>cv2.imshow(<span class="hljs-string">&#x27;o&#x27;</span>,img1)<br>dst=cv2.undistort(img1,mtx,dis,<span class="hljs-literal">None</span>,mtx)<br>cv2.imshow(<span class="hljs-string">&#x27;d&#x27;</span>,dst)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.imwrite(<span class="hljs-string">&#x27;correct.jpg&#x27;</span>,dst)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p>实现结果<br><img src="/img/%E6%A3%8B%E7%9B%98%E6%A0%BC%E7%BB%93%E6%9E%9C1.jpeg" alt="img"></p><p><img src="/img/%E6%A3%8B%E7%9B%98%E6%A0%BC%E7%BB%93%E6%9E%9C2.jpeg" alt="img"></p><h1 id="透视变化为了展现出感兴趣的区域（车道线区域）"><a href="#透视变化为了展现出感兴趣的区域（车道线区域）" class="headerlink" title="透视变化为了展现出感兴趣的区域（车道线区域）"></a>透视变化为了展现出感兴趣的区域（车道线区域）</h1><p>在原图中车道线区域可以认为一个梯形，现在要把这个区域变成我们俯视时看到的场景便于车道线接下来的识别操作本文选取<br>scr&#x3D;np.float32([[575,460],[700,460],[1096,720],[200,720]])<br>dst&#x3D;np.float32([[200,0],[950,0],[950,720],[200,720]])<br>scr可以认为原图中的梯形区域dst可以认为我们俯视车道线是的矩形区域通过cv2.getPerspectiveTransform()来获得变换矩阵<br>再带入cv2.warpPerspective(img,M,(w,h),flags&#x3D;cv2.INTER_LINEAR)完成透视变换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img=cv2.imread(<span class="hljs-string">&#x27;correct.jpg&#x27;</span>)<br>h,w=img.shape[:<span class="hljs-number">2</span>]<br>scr=np.float32([[<span class="hljs-number">575</span>,<span class="hljs-number">460</span>],[<span class="hljs-number">700</span>,<span class="hljs-number">460</span>],[<span class="hljs-number">1096</span>,<span class="hljs-number">720</span>],[<span class="hljs-number">200</span>,<span class="hljs-number">720</span>]])<br>dst=np.float32([[<span class="hljs-number">200</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">950</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">950</span>,<span class="hljs-number">720</span>],[<span class="hljs-number">200</span>,<span class="hljs-number">720</span>]])<br>M=cv2.getPerspectiveTransform(scr,dst,<span class="hljs-literal">None</span>)<br>Minv=cv2.getPerspectiveTransform(dst,scr,<span class="hljs-literal">None</span>)<br>img1=cv2.warpPerspective(img,M,(w,h),flags=cv2.INTER_LINEAR)<br>plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">6</span>))<br>plt.subplot(<span class="hljs-number">121</span>),plt.imshow(img)<br>plt.subplot(<span class="hljs-number">122</span>),plt.imshow(img1)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%871.jpeg" alt="img"></p><h1 id="通过hls图像提取白色车道线，通过lab图像提取黄色车道线"><a href="#通过hls图像提取白色车道线，通过lab图像提取黄色车道线" class="headerlink" title="通过hls图像提取白色车道线，通过lab图像提取黄色车道线"></a>通过hls图像提取白色车道线，通过lab图像提取黄色车道线</h1><p>接下来第三步开始识别车道线，由于车道线是黄色和白色，现在目的是将黄色线和白色线分别提出来最后在组合在一张图上完成检测</p><p>首先是通过HSL颜色空间提取出白色车线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">hls=cv2.cvtColor(img1,cv2.COLOR_BGR2HLS)<br>lab=cv2.cvtColor(img1,cv2.COLOR_BGR2Lab)<br><br><span class="hljs-comment">#print(hls)</span><br>L_channel=hls[:,:,<span class="hljs-number">1</span>]<br>L_channel=L_channel*(<span class="hljs-number">255</span>/np.<span class="hljs-built_in">max</span>(L_channel))<br>h,w=L_channel.shape[:<span class="hljs-number">2</span>]<br><br>binary_out=np.zeros_like(L_channel)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(h):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(w):<br>        <span class="hljs-keyword">if</span> L_channel[i][j]&gt;=<span class="hljs-number">220</span> <span class="hljs-keyword">and</span> L_channel[i][j]&lt;=<span class="hljs-number">255</span>:<br>            binary_out[i][j]=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%872.jpeg" alt="img"><br><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%873.jpeg" alt="img"><br><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%874.jpeg" alt="img"></p><p>再通过Lab颜色空间提取黄色车道线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">b_channel=lab[:,:,<span class="hljs-number">2</span>]<br><span class="hljs-keyword">if</span> b_channel.<span class="hljs-built_in">max</span>()&gt;<span class="hljs-number">100</span>:<br>    b_channel=b_channel*(<span class="hljs-number">255</span>/np.<span class="hljs-built_in">max</span>(b_channel))<br>lab_binary=np.zeros_like(b_channel)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(h):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(w):<br>        <span class="hljs-keyword">if</span> b_channel[i][j]&gt;=<span class="hljs-number">195</span> <span class="hljs-keyword">and</span> b_channel[i][j]&lt;=<span class="hljs-number">255</span>:<br>            lab_binary[i][j]=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%875.jpeg" alt="img"><br><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%876.jpeg" alt="img"><br><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%877.jpeg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">out=np.zeros_like(lab_binary)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(h):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(w):<br>        <span class="hljs-keyword">if</span> binary_out[i][j]==<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> lab_binary[i][j]==<span class="hljs-number">1</span>:<br>            out[i][j]=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%878.jpeg" alt="img"><br><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%879.jpeg" alt="img"><br><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%8710.jpeg" alt="img"></p><h1 id="使用滑动窗口来识别车道线"><a href="#使用滑动窗口来识别车道线" class="headerlink" title="使用滑动窗口来识别车道线"></a>使用滑动窗口来识别车道线</h1><p>接下来是滑动窗口识别车道线<br>经过提取车道线后，可以的到非黑即白的二值化图像，可以利用直方图统计的方法来确定车道线在图像上的位置如下直方图所示横轴为图像水平坐标系，纵轴为像素个数<br><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%8711.jpeg" alt="img"><br><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%8712.jpeg" alt="img"></p><p>实现代码<br>直方图统计是由np.sum（）axis&#x3D;0是压缩行，每一列的进行相加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">histogram = np.<span class="hljs-built_in">sum</span>(out[:,:], axis=<span class="hljs-number">0</span>)<br>x=np.arange(<span class="hljs-number">1280</span>)<br>plt.plot(x,histogram, linewidth=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h1 id="使用滑动窗口来识别车道线-1"><a href="#使用滑动窗口来识别车道线-1" class="headerlink" title="使用滑动窗口来识别车道线"></a>使用滑动窗口来识别车道线</h1><p>接下来就是实现滑动窗口，首先定义窗口大小本次实验采用9个窗口那么高度为img.shape[0]&#x2F;9</p><p>再找到图像中车道线最大值处（使用np.argmax），leftx_base,与rightx_base分别为第一个窗口的中点，将宽度设成100得到一个宽200高80的窗口。</p><p>接下来开始遍历图像寻找非0且的像素点，通过nonzero实现将其索引值保存在left_lane_inds（左车道线）右车道线同理</p><p>在寻找的过程中，如果非0的像素点超过一定的阈值那么将窗口中心点坐标改变。</p><p>以上就是滑动窗口的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python">leftx_base = np.argmax(histogram[:midpoint])<br>rightx_base = np.argmax(histogram[midpoint:]) + midpoint<br><span class="hljs-comment">#窗口</span><br>windows=<span class="hljs-number">9</span><br>windows_height=out.shape[<span class="hljs-number">0</span>]//windows<br>margin=<span class="hljs-number">100</span><br>minpix=<span class="hljs-number">50</span><br><span class="hljs-comment">#统计</span><br>nonzero=out.nonzero()<br>nonzeroy=np.array(nonzero[<span class="hljs-number">0</span>])<br>nonzerox=np.array(nonzero[<span class="hljs-number">1</span>])<br><br>Left_lane_inds=[]<br>Right_lane_inds=[]<br>leftx_current = leftx_base<br>rightx_current = rightx_base<br><br><span class="hljs-keyword">for</span> window <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(windows):<br>    win_y_low=out.shape[<span class="hljs-number">0</span>]-(window+<span class="hljs-number">1</span>)*windows_height<br>    win_y_high = out.shape[<span class="hljs-number">0</span>] - window  * windows_height<br>    win_xleft_low= leftx_current-margin<br>    win_xleft_high = leftx_current + margin<br>    win_xright_low = rightx_current - margin<br>    win_xright_high = rightx_current + margin<br><br>    <span class="hljs-comment">#Draw</span><br>    cv2.rectangle(out_img,(win_xleft_low,win_y_low),(win_xleft_high,win_y_high),[<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>],<span class="hljs-number">2</span>)<br>    cv2.rectangle(out_img, (win_xright_low, win_y_low), (win_xright_high, win_y_high), [<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>], <span class="hljs-number">2</span>)<br><br>    good_left_inds =((nonzerox&gt;=win_xleft_low)&amp;(nonzerox&lt;win_xleft_high)&amp;(nonzeroy&gt;=win_y_low)&amp;(nonzeroy&lt;win_y_high)).nonzero()[<span class="hljs-number">0</span>]<br>    good_right_inds =((nonzerox&gt;=win_xright_low)&amp;(nonzerox&lt;win_xright_high)&amp;(nonzeroy&gt;=win_y_low)&amp;(nonzeroy&lt;win_y_high)).nonzero()[<span class="hljs-number">0</span>]<br><br>    Left_lane_inds.append(good_left_inds)<br>    Right_lane_inds.append(good_right_inds)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(good_left_inds)&gt;minpix:leftx_current = np.int32(np.mean(nonzerox[good_left_inds]))<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(good_right_inds) &gt; minpix: rightx_current = np.int32(np.mean(nonzerox[good_right_inds]))<br><br>Left_lane_inds=np.concatenate(Left_lane_inds)<br>Right_lane_inds=np.concatenate(Right_lane_inds)<br><br>lefttx=nonzerox[Left_lane_inds]<br>leftty=nonzeroy[Left_lane_inds]<br>righttx=nonzerox[Right_lane_inds]<br>rightty=nonzeroy[Right_lane_inds]<br><br><br>left_fit=np.polyfit(leftty,lefttx,<span class="hljs-number">2</span>)<br>right_fit=np.polyfit(rightty,righttx,<span class="hljs-number">2</span>)<br><br>ploty=np.linspace(<span class="hljs-number">0</span>,out.shape[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>,out.shape[<span class="hljs-number">0</span>])<br>left_fitx=left_fit[<span class="hljs-number">0</span>]*ploty**<span class="hljs-number">2</span>+ploty*left_fit[<span class="hljs-number">1</span>]+left_fit[<span class="hljs-number">2</span>]<br>right_fitx=right_fit[<span class="hljs-number">0</span>]*ploty**<span class="hljs-number">2</span>+ploty*right_fit[<span class="hljs-number">1</span>]+right_fit[<span class="hljs-number">2</span>]<br>out_img[leftty, lefttx] = [<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>out_img[rightty, righttx] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>]<br><br><span class="hljs-comment">#plt.plot(left_fitx, ploty,  linewidth=2)</span><br><span class="hljs-comment">#plt.plot(right_fitx, ploty,  linewidth=2)</span><br><br>plt.subplot(<span class="hljs-number">121</span>),plt.imshow(img1,<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.subplot(<span class="hljs-number">122</span>),plt.imshow(out_img,<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%8713.jpeg" alt="img"></p><h1 id="二项式拟合求出车道线曲线"><a href="#二项式拟合求出车道线曲线" class="headerlink" title="二项式拟合求出车道线曲线"></a>二项式拟合求出车道线曲线</h1><p>接着通过上一步得到的非0点的索引值（即像素的横纵坐标）来进行二项式多项式拟合得到下图<br>二次函数表示为y&#x3D;ax**2+bx+c使用函数np.polyfit()带入坐标值返回[a,b,c]二次函数三个系数，而ploty可以认为表示的是自变量通过np.linspace得到<br><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%8714.jpeg" alt="img"><br>通过上述得到的二次项系数在图像中分别获得二次项曲线的坐标（x,y）分别用pts_left与pts_right保存，通过cv2.fillpoly填充车道线之间颜色最后逆投影到原图像上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">ploty=np.linspace(<span class="hljs-number">0</span>,binary_warped.shape[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>,binary_warped.shape[<span class="hljs-number">0</span>])<br>   left_fitx = left_fit[<span class="hljs-number">0</span>] * ploty ** <span class="hljs-number">2</span> + left_fit[<span class="hljs-number">1</span>] * ploty + left_fit[<span class="hljs-number">2</span>]<br>   right_fitx = right_fit[<span class="hljs-number">0</span>] * ploty ** <span class="hljs-number">2</span> + right_fit[<span class="hljs-number">1</span>] * ploty + right_fit[<span class="hljs-number">2</span>]<br>   warp_zero = np.zeros_like(binary_warped).astype(np.uint8)<br>   color_warp=np.dstack((warp_zero,warp_zero,warp_zero))<br>   pts_left = np.array([np.transpose(np.vstack([left_fitx, ploty]))])<br>   pts_right = np.array([np.flipud(np.transpose(np.vstack([right_fitx, ploty])))])<br>   pts = np.hstack((pts_left, pts_right))<br>   cv2.fillPoly(color_warp,np.int_([pts]),(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>))<br><br>   newwarp=cv2.warpPerspective(color_warp, Minv, (undist.shape[<span class="hljs-number">1</span>], undist.shape[<span class="hljs-number">0</span>]))<br>   result = cv2.addWeighted(undist, <span class="hljs-number">1</span>, newwarp, <span class="hljs-number">0.3</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%8715.jpeg" alt="img"></p><h1 id="求出曲率半径和偏离位置"><a href="#求出曲率半径和偏离位置" class="headerlink" title="求出曲率半径和偏离位置"></a>求出曲率半径和偏离位置</h1><p>还有曲率半径和偏离位置的求取</p><p>由于是二次函数y&#x3D;ax**2+bx+c可以由公式求得曲率半径为<br>$$(1+{y}’^{2})^{1.5}\over{y}’’$$<br>而偏离位置为车道线之间的距离与图像中心距离之差</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">ploty = np.linspace(<span class="hljs-number">0</span>, binary_warped.shape[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, binary_warped.shape[<span class="hljs-number">0</span>])<br>leftx = left_fit[<span class="hljs-number">0</span>] * ploty ** <span class="hljs-number">2</span> + left_fit[<span class="hljs-number">1</span>] * ploty + left_fit[<span class="hljs-number">2</span>]<br>rightx = right_fit[<span class="hljs-number">0</span>] * ploty ** <span class="hljs-number">2</span> + right_fit[<span class="hljs-number">1</span>] * ploty + right_fit[<span class="hljs-number">2</span>]<br><br>ym_per_pix = <span class="hljs-number">30</span> / <span class="hljs-number">720</span>  <span class="hljs-comment"># meters per pixel in y dimension</span><br>xm_per_pix = <span class="hljs-number">3.7</span> / <span class="hljs-number">700</span>  <span class="hljs-comment"># meters per pixel in x dimension</span><br>y_eval = np.<span class="hljs-built_in">max</span>(ploty)<br>left_cur_fit=np.polyfit(ploty*ym_per_pix,leftx*xm_per_pix,<span class="hljs-number">2</span>)<br>right_cur_fit=np.polyfit(ploty*ym_per_pix,rightx*xm_per_pix,<span class="hljs-number">2</span>)<br><br>left_curverad=((<span class="hljs-number">1</span> + (<span class="hljs-number">2</span>*left_cur_fit[<span class="hljs-number">0</span>]*y_eval*ym_per_pix + left_cur_fit[<span class="hljs-number">1</span>])**<span class="hljs-number">2</span>)**<span class="hljs-number">1.5</span>) / np.absolute(<span class="hljs-number">2</span>*left_cur_fit[<span class="hljs-number">0</span>])<br>right_curverad=((<span class="hljs-number">1</span> + (<span class="hljs-number">2</span>*right_cur_fit[<span class="hljs-number">0</span>]*y_eval*ym_per_pix + right_cur_fit[<span class="hljs-number">1</span>])**<span class="hljs-number">2</span>)**<span class="hljs-number">1.5</span>) / np.absolute(<span class="hljs-number">2</span>*right_cur_fit[<span class="hljs-number">0</span>])<br>curverad=(left_curverad+right_curverad)/<span class="hljs-number">2.</span><br><span class="hljs-comment">#</span><br>lane_width=np.absolute(leftx[<span class="hljs-number">719</span>]-rightx[<span class="hljs-number">719</span>])<br>lane_xm_per_pix=<span class="hljs-number">3.7</span>/lane_width<br>veh_pos=(leftx[<span class="hljs-number">719</span>]+rightx[<span class="hljs-number">719</span>])*lane_xm_per_pix/<span class="hljs-number">2.</span><br>cen_pos=binary_warped.shape[<span class="hljs-number">1</span>]*lane_xm_per_pix/<span class="hljs-number">2.</span><br>distance_from_center=np.absolute(cen_pos-veh_pos)<br></code></pre></td></tr></table></figure><h1 id="逆投影到原图上"><a href="#逆投影到原图上" class="headerlink" title="逆投影到原图上"></a>逆投影到原图上</h1><p><img src="/img/%E5%AE%9E%E9%AA%8C%E5%9B%BE%E7%89%8716.jpeg" alt="img"></p><h1 id="显示检测过程"><a href="#显示检测过程" class="headerlink" title="显示检测过程"></a>显示检测过程</h1><p>最终实现视频</p><div style="position: relative; width: 100%; height: 10; padding-bottom: 75%;"><iframe src="https://www.bilibili.com/video/BV1os4y1k7mt/?vd_source=de53b9bf2fb1c88037580bfd620f285a" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 110%; height: 115%; left: 0; top: 0;"> </iframe></div>]]></content>
    
    
    
    <tags>
      
      <tag>一个标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown</title>
    <link href="/2023/06/21/Markdown/"/>
    <url>/2023/06/21/Markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h1><p>下面是使用Markdown设置标题(几号标题)</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 一级（注意#后面要有空格）<br>## 二级<br>### 三级<br>#### 四级<br>##### 五级<br>###### 六级<br></code></pre></td></tr></table></figure><h1 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h1><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>进行段落的换行操作有</p><p>1.进行两次换行<br>2.空格2次再换行</p><h2 id="Markdown-字体"><a href="#Markdown-字体" class="headerlink" title="Markdown 字体"></a>Markdown 字体</h2><p>如下所示: </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">*斜体文本*<span class="hljs-params">-----------</span>（一个*号是斜体）<br><br>_斜体文本_<span class="hljs-params">-----------</span>（一个下划是斜体）<br><br>**粗体文本**<span class="hljs-params">---------</span>（两个*号是粗体）<br><br>__粗体文本__<span class="hljs-params">---------</span>（两个下划是粗体）<br><br>***粗斜体文本***<span class="hljs-params">-----</span>（三个*号是粗斜）<br><br>___粗斜体文本___<span class="hljs-params">-----</span>（三个下划是粗斜）<br><br>~~删除线文本~~<span class="hljs-params">-------</span>（两个波浪是删除）<br><br>&lt;u&gt;下划线文本&lt;<span class="hljs-string">/u</span>&gt;<span class="hljs-params">----</span>（一个u符是下划）<br><br>创建一个脚注<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="阿巴阿巴[//]: # (注释文本，不会在浏览器中显示。)[^_^]: # (注释文本，不会在浏览器中显示。)">[1]</span></a></sup><br><br># Markdown 列表共有三种列表## 有序列表就是用数字加.的方式<hexoPostRenderCodeBlock><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 这样<br><span class="hljs-bullet">2.</span> 表示<br><span class="hljs-bullet">3.</span> .是在英文输入法下且之后内容前有个空格<br></code></pre></td></tr></table></figure><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>使用了+（加号），-（减号），<em>（</em>号）；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 听话的便当<br><br><span class="hljs-bullet">*</span> 听话的便当<br><br><span class="hljs-bullet">*</span> 听话的便当<br><br><span class="hljs-bullet">+</span> 注意<br><br><span class="hljs-bullet">+</span> 注意<br><br><span class="hljs-bullet">+</span> 注意<br><br><span class="hljs-bullet">-</span> 符号后加空格<br><br><span class="hljs-bullet">-</span> 符号后加空格<br><br><span class="hljs-bullet">-</span> 符号后加空格<br></code></pre></td></tr></table></figure><p>输出为：一个点加内容</p><h2 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h2><h3 id="有序嵌套列表"><a href="#有序嵌套列表" class="headerlink" title="有序嵌套列表"></a>有序嵌套列表</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">1</span>. 听话的便当<br>    - 听话的便当<br>    - 听话的便当<br><span class="hljs-number">2</span>. 注意空格<br>    + 空格<br>    + 空格<br><span class="hljs-number">3</span>. <span class="hljs-string">&quot;-&quot;</span>，<span class="hljs-string">&quot;*&quot;</span>和<span class="hljs-string">&quot;+&quot;</span>前面有四个空格<br>    * <span class="hljs-string">&quot;-&quot;</span>，<span class="hljs-string">&quot;*&quot;</span>和<span class="hljs-string">&quot;+&quot;</span>前面有四个空格<br>    * <span class="hljs-string">&quot;-&quot;</span>，<span class="hljs-string">&quot;*&quot;</span>和<span class="hljs-string">&quot;+&quot;</span>前面有四个空格<br></code></pre></td></tr></table></figure><h3 id="无序嵌套列表"><a href="#无序嵌套列表" class="headerlink" title="无序嵌套列表"></a>无序嵌套列表</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c">- 就是把数字换成符号<br>    - 就是把数字换成符号<br>    - 就是把数字换成符号<br>+ 注意空格<br>    + 空格<br>    + 空格<br>* <span class="hljs-string">&quot;-&quot;</span>，<span class="hljs-string">&quot;*&quot;</span>和<span class="hljs-string">&quot;+&quot;</span>前面有四个空格<br>    * <span class="hljs-string">&quot;-&quot;</span>，<span class="hljs-string">&quot;*&quot;</span>和<span class="hljs-string">&quot;+&quot;</span>前面有四个空格<br>    * <span class="hljs-string">&quot;-&quot;</span>，<span class="hljs-string">&quot;*&quot;</span>和<span class="hljs-string">&quot;+&quot;</span>前面有四个空格<br></code></pre></td></tr></table></figure><h1 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h1><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">听话的便当</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Markdown</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">区块</span><br></code></pre></td></tr></table></figure><p>区块里可以使用列表，列表里可以使用区块</p><h1 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h1><h1 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">这是[听话的便当](https:<span class="hljs-regexp">//</span>www/thdbd.gitbook.io)的网站<br><br>或者<br><br>这是听话的便当的网站 &lt;https:<span class="hljs-regexp">//</span>www.thdbd.gitbook.io&gt; <br>[<span class="hljs-regexp">//</span>]: <span class="hljs-comment"># (直接显示链接)</span><br></code></pre></td></tr></table></figure><p>或者像论文文献一样</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less">这是我的<span class="hljs-selector-attr">[网站]</span><span class="hljs-selector-attr">[1]</span><br><br>这是我的<span class="hljs-selector-attr">[第二个网站]</span><span class="hljs-selector-attr">[2]</span><br><br>······<br><br>这是我的<span class="hljs-selector-attr">[网站]</span><span class="hljs-selector-attr">[1]</span><br><br>这是我的<span class="hljs-selector-attr">[第二个网站]</span><span class="hljs-selector-attr">[2]</span><br><br><span class="hljs-selector-attr">[1]</span>: <span class="hljs-selector-tag">https</span>:<span class="hljs-comment">//www.github.io/</span><br><span class="hljs-selector-attr">[2]</span>: <span class="hljs-selector-tag">https</span>:<span class="hljs-comment">//www.gitbook.io/</span><br></code></pre></td></tr></table></figure><h1 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h1><p>Markdown 表格使用 | 来分隔不同的单元格；<br>使用 - 来分隔表头和其他行；<br>例如：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">  thdbd  </span>|<span class="hljs-string">  thdbd  </span>|<br>|<span class="hljs-string">  -----  </span>|<span class="hljs-string">  -----  </span>|<br>|<span class="hljs-string">   123   </span>|<span class="hljs-string">   456   </span>|<br>|<span class="hljs-string">   321   </span>|<span class="hljs-string">   654   </span>|<br><br><br>```  <br>也可以设计一下表格内文字的居中方式：<br>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。<br><br><br>例如：<br><br><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">thdbd</th><th align="center">thdbd</th></tr></thead><tbody><tr><td align="center">123</td><td align="center">456</td></tr><tr><td align="center">321</td><td align="center">654</td></tr></tbody></table><pre><code class="hljs">&lt;section class=&quot;footnotes&quot;&gt;&lt;div class=&quot;footnote-list&quot;&gt;&lt;ol&gt;&lt;li&gt;&lt;span id=&quot;fn:1&quot; class=&quot;footnote-text&quot;&gt;&lt;span&gt;阿巴阿巴&lt;br&gt;&lt;br&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x2F;&amp;#x2F;&lt;/span&gt;]: &lt;span class=&quot;hljs-comment&quot;&gt;# (注释文本，不会在浏览器中显示。)&lt;/span&gt;&lt;br&gt;&lt;br&gt;[^_^]: &lt;span class=&quot;hljs-comment&quot;&gt;# (注释文本，不会在浏览器中显示。)&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/hexoPostRenderCodeBlock&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot; class=&quot;footnote-backref&quot;&gt; ↩&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/section&gt;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>一个标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown实例</title>
    <link href="/2023/06/21/Markdown%E5%AE%9E%E4%BE%8B/"/>
    <url>/2023/06/21/Markdown%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="欢迎使用Markdown编辑器"><a href="#欢迎使用Markdown编辑器" class="headerlink" title="欢迎使用Markdown编辑器"></a>欢迎使用Markdown编辑器</h1><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p><h2 id="新的改变"><a href="#新的改变" class="headerlink" title="新的改变"></a>新的改变</h2><p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p><ol><li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li><li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li><li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li><li>全新的 <strong>KaTeX数学公式</strong> 语法；</li><li>增加了支持<strong>甘特图的mermaid语法<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[mermaid语法说明](https://mermaidjs.github.io/)"><a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">1</a></span></a></sup></strong> 功能；</li><li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li><li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li><li>增加了 <strong>检查列表</strong> 功能。</li></ol><h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br>查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br>替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p><h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>&#x3D;&#x3D;标记文本&#x3D;&#x3D;</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p>链接: <a href="https://www.csdn.net/">link</a>.</p><p>图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw" alt="Alt"></p><p>带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</a> &#x3D;30x30)</p><p>居中的图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center" alt="Alt"></p><p>居中并且带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</a> &#x3D;30x30)</p><p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p><h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/console/configBlog">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// An highlighted block</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input checked="" disabled="" type="checkbox"> 完成任务</li></ul><h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：</p><table><thead><tr><th>项目</th><th>Value</th></tr></thead><tbody><tr><td>电脑</td><td>$1600</td></tr><tr><td>手机</td><td>$12</td></tr><tr><td>导管</td><td>$1</td></tr></tbody></table><h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右</p><table><thead><tr><th align="center">第一列</th><th align="right">第二列</th><th align="left">第三列</th></tr></thead><tbody><tr><td align="center">第一列文本居中</td><td align="right">第二列文本居右</td><td align="left">第三列文本居左</td></tr></tbody></table><h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：</p><table><thead><tr><th>TYPE</th><th>ASCII</th><th>HTML</th></tr></thead><tbody><tr><td>Single backticks</td><td><code>&#39;Isn&#39;t this fun?&#39;</code></td><td>‘Isn’t this fun?’</td></tr><tr><td>Quotes</td><td><code>&quot;Isn&#39;t this fun?&quot;</code></td><td>“Isn’t this fun?”</td></tr><tr><td>Dashes</td><td><code>-- is en-dash, --- is em-dash</code></td><td>– is en-dash, — is em-dash</td></tr></tbody></table><h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><dl><dt>Markdown</dt><dd>Text-to-HTML conversion tool</dd></dl><dl><dt>Authors<br>:  John</dt><dd>Luke</dd></dl><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="注脚的解释"><a href="https://mermaidjs.github.io/">2</a></span></a></sup></p><h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p><p>*[HTML]:   超文本标记语言</p><h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/">KaTeX</a>:</p><p>Gamma公式展示 $\Gamma(n) &#x3D; (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p><p>$$<br>\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p><blockquote><p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">here</a>.</p></blockquote><h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><pre><code class=" mermaid">gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section 现有任务        已完成               :done,    des1, 2014-01-06,2014-01-08        进行中               :active,  des2, 2014-01-09, 3d        计划一               :         des3, after des2, 5d        计划二               :         des4, after des3, 5d</code></pre><ul><li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="UML-图表"><a href="#UML-图表" class="headerlink" title="UML 图表"></a>UML 图表</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/">Mermaid</a>. 例如下面产生的一个序列图：</p><pre><code class=" mermaid">sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</code></pre><p>这将产生一个流程图。:</p><pre><code class=" mermaid">graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D</code></pre><ul><li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：</p><pre><code class=" mermaid">flowchatst=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/">这儿</a>.</li></ul><h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://mermaidjs.github.io/">mermaid语法说明</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>注脚的解释<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>NOne</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/06/21/hello-world/"/>
    <url>/2023/06/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
